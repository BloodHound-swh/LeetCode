/**
 * 让我们从另一个经典问题开始：

给定一个数组和一个值，原地删除该值的所有实例并返回新的长度。

如果我们没有空间复杂度上的限制，那就更容易了。我们可以初始化一个新的数组来存储答案。如果元素不等于给定的目标值，则迭代原始数组并将元素添加到新的数组中。

实际上，它相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置。


重新考虑空间限制
现在让我们重新考虑空间受到限制的情况。 

我们可以采用类似的策略，我们继续使用两个指针：一个仍然用于迭代，而第二个指针总是指向下一次添加的位置。 

以下代码可以供你参考：
 */

public int removeElement(int[] nums, int val) {
    int k = 0;
    for (int i = 0; i < nums.length; ++i) {
        if (nums[i] != val) {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}

/**
 * 这是你需要使用双指针技巧的一种非常常见的情况：

同时有一个慢指针和一个快指针。

解决这类问题的关键是

确定两个指针的移动策略。

与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心想法来决定你的运动策略。
 */